---
description: L'instance d'application indique conventionnellement l'application Fiber.
---

# üöÄ Application

## Nouveau

Cette m√©thode cr√©e une nouvelle **application** nomm√©e instance. Vous pouvez passer les param√®tres facultatifs [ ](app.md#settings)lors de la cr√©ation d'une nouvelle instance

{% code title="Signature" %}
```go
fibres.Nouveau(param√®tres...*Param√®tres) *Application
```
{% endcode %}

{% code title="Example" %}
```go
package main

import "github.com/gofiber/fiber"

func main() {
    app := fiber.New()

    // ...

    application√âcoute(3000)
}
```
{% endcode %}

## R√©glages

Vous pouvez passer les param√®tres de l'application en appelant `Nouveau`.

{% code title="Example" %}
```go
func main() {
    // Passer les param√®tres en cr√©ant une nouvelle instance
    app := fiber.Nouveau(&fibres.Param√®tres{
        Prefork: true,
        CaseSensitive: true,
        StrictRouting: true,
        ServerHeader: "Fiber",
    })

    // ...

    application√âcoute(3000)
}
```
{% endcode %}

Ou modifiez les param√®tres apr√®s l'initialisation d'une application ``.

{% code title="Example" %}
```go
func main() {
    app := fibre.New()

    // Ou changer les param√®tres apr√®s la cr√©ation d'une application
    instance.Param√®tres.Prefork = true
    app.Param√®tres.Sensible √† la casse = application
    vraie.Param√®tres.StrictRouting = vrai
    application.Param√®tres.ServerHeader = "Fiber"

    // ...

    application√âcoute(3000)
}
```
{% endcode %}

**Param√®tres** **champs**

| Propri√©t√©                                | Type de texte          | Libell√©                                                                                                                                                                                                                                                                               | Par d√©faut        |
|:---------------------------------------- |:---------------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |:----------------- |
| Prefork                                  | `bool√©en`              | Active l'utilisation de l'option[`SO_REUSEPORT`](https://lwn.net/Articles/542629/)du socket. Cela fera appara√Ætre plusieurs processus Go en √©coutant sur le m√™me port. en savoir plus sur [le ramassage des prises](https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/). | `Faux`            |
| En-t√™te du serveur                       | `cha√Æne de caract√®res` | Active l'en-t√™te HTTP `Server` avec la valeur donn√©e.                                                                                                                                                                                                                                 | `""`              |
| Routage strict                           | `bool√©en`              | Lorsque cette option est activ√©e, le routeur traite `/foo` et `/foo/` comme diff√©rent. Sinon, le routeur traite `/foo` et `/foo/` comme le m√™me.                                                                                                                                      | `Faux`            |
| Sensible √† la casse                      | `bool√©en`              | Lorsque cette option est activ√©e, `/Foo` et `/foo` sont des routes diff√©rentes. Lorsque d√©sactiv√©, `/Foo`et `/foo` sont trait√©s de la m√™me fa√ßon.                                                                                                                                     | `Faux`            |
| Immuable                                 | `bool√©en`              | Lorsque cette option est activ√©e, toutes les valeurs retourn√©es par les m√©thodes contextuelles sont immuables. Par d√©faut, ils sont valides jusqu'√† ce que vous reveniez du gestionnaire, voir le probl√®me [\#185](https://github.com/gofiber/fiber/issues/185).                    | `Faux`            |
| Limite de corps                          | `Indice`               | D√©finit la taille maximale autoris√©e pour un corps de requ√™te, si la taille d√©passe la limite configur√©e, it sends `413 - Request Entity Too Large` r√©ponse.                                                                                                                          | `4 * 1024 * 1024` |
| CompressedFileSuffix                     | `cha√Æne de caract√®res` | Ajoute le suffixe au nom du fichier original et essaie de sauvegarder le fichier compress√© r√©sultant sous le nouveau nom de fichier.                                                                                                                                                  | `".fiber.gz"`     |
| Conmonnaie                               | `Indice`               | Nombre maximum de connexions simultan√©es.                                                                                                                                                                                                                                             | `256 * 1024`      |
| D√©sactiver Keepalive                     | `bool√©en`              | D√©sactiver les connexions en maintenance, le serveur fermera les connexions entrantes apr√®s avoir envoy√© la premi√®re r√©ponse au client                                                                                                                                                | `Faux`            |
| D√©sactiver la date par d√©faut            | `bool√©en`              | Lorsqu'il est d√©fini √† true provoque l'exclusion de l'en-t√™te de date par d√©faut de la r√©ponse.                                                                                                                                                                                       | `Faux`            |
| D√©sactiver le type de contenu par d√©faut | `bool√©en`              | Lorsqu'il est d√©fini √† true, provoque l'exclusion de l'en-t√™te par d√©faut de Content-Type de la r√©ponse.                                                                                                                                                                              | `Faux`            |
| D√©sactiver le message de d√©marrage       | `bool√©en`              | Lorsqu'il est d√©fini √† true, il n'affichera pas la fibre ASCII et "√©couter" sur le message                                                                                                                                                                                            | `Faux`            |
| D√©sactiver la normalisation des en-t√™tes | `bool√©en`              | Par d√©faut, tous les noms d'en-t√™te sont normalis√©s : conteNT-tYPE -&gt; Content-Type                                                                                                                                                                                           | `Faux`            |
| ETag                                     | `bool√©en`              | Activer ou d√©sactiver la g√©n√©ration d'en-t√™te ETag, car les Etags faibles et forts sont g√©n√©r√©s en utilisant la m√™me m√©thode de hachage \(CRC-32\\). Les ETags faibles sont la valeur par d√©faut lorsqu‚Äôils sont activ√©s.                                                          | `Faux`            |
| Mod√®les                                  | `Mod√®les`              | Les gabarits sont l'interface qui entoure la fonction Render. Consultez notre [**Mod√®le Middleware**](middleware.md#template) pour les moteurs pris en charge.                                                                                                                        | `Ni`              |
| D√©lai de lecture                         | `horaire.Dur√©e`        | Le temps allou√© pour lire la demande compl√®te, y compris le corps. Le d√©lai d'attente par d√©faut est illimit√©.                                                                                                                                                                        | `Ni`              |
| D√©lai d'√©criture d√©pass√©                 | `horaire.Dur√©e`        | La dur√©e maximale avant que le chronom√©trage n'√©crive la r√©ponse. Le d√©lai d'attente par d√©faut est illimit√©.                                                                                                                                                                         | `Ni`              |
| D√©lai d'inactivit√© d√©pass√©               | `horaire.Dur√©e`        | Le temps maximum d'attente pour la prochaine requ√™te lorsque keep-alive est activ√©. Si IdleTimeout est z√©ro, la valeur de ReadTimeout est utilis√©e.                                                                                                                                   | `Ni`              |

## Statique

Utilisez la m√©thode **Static** pour servir des fichiers statiques tels que **images**, **CSS** et **JavaScript**.

{% hint style="info" %}
Par d√©faut, **Static** servira les fichiers `index.html` en r√©ponse √† une requ√™te dans un r√©pertoire.
{% endhint %}

{% code title="Signature" %}
```go
applicationStatic(pr√©fixe, cha√Æne racine, config ...Static) // => avec pr√©fixe
```
{% endcode %}

Utilisez le code suivant pour servir des fichiers dans un r√©pertoire nomm√© `./public`

{% code title="Example" %}
```go
applicationStatic("/", "./public")

// => http://localhost:3000/hello.html
// => http://localhost:3000/js/jquery.js
// => http://localhost:3000/css/style.css
```
{% endcode %}

Pour servir √† partir de plusieurs r√©pertoires, vous pouvez utiliser **Static** plusieurs fois.

{% code title="Example" %}
```go
// Servir des fichiers depuis le r√©pertoire "./public":
app.Static("/", "./public")

// Servir des fichiers depuis le r√©pertoire "./files" :
app.Statistique ("/", "./fichiers")
```
{% endcode %}

{% hint style="info" %}
Utilisez un cache proxy invers√© comme [**NGINX**](https://www.nginx.com/resources/wiki/start/topics/examples/reverseproxycachingexample/) pour am√©liorer les performances des actifs statiques.
{% endhint %}

Vous pouvez utiliser n'importe quel pr√©fixe de chemin virtuel \(_o√π le chemin n'existe pas dans le syst√®me de fichiers_\) pour les fichiers qui sont servis par la m√©thode **Static** , sp√©cifiez un chemin de pr√©fixe pour le r√©pertoire statique, comme indiqu√© ci-dessous:

{% code title="Example" %}
```go
applicationStatic("/static", "./public")

// => http://localhost:3000/static/hello.html
// => http://localhost:3000/static/js/jquery.js
// => http://localhost:3000/static/css/style.css
```
{% endcode %}

Si vous voulez avoir un peu plus de contr√¥le en ce qui concerne les param√®tres de gestion des fichiers statiques. Vous pouvez utiliser la fibre `.Structure statique` pour activer des param√®tres sp√©cifiques.

{% code title="fibre.Statistique{}" %}
```go
// Static repr√©sente les param√®tres pour servir les fichiers statiques
type Static struct {
    // compresse de mani√®re transparente les r√©ponses si la valeur est true
    // Cela fonctionne diff√©remment que le github. om/gofiber/compression middleware
    // Le serveur essaie de minimiser l'utilisation du processeur en mettant en cache les fichiers compress√©s.
    // Il ajoute le suffixe ".fiber.gz" au nom du fichier original.
    // Optionnel. Valeur par d√©faut false
    Compress bool
    // Active les requ√™tes d'intervalle d'octets si d√©fini √† true.
    // Optionnel. Valeur par d√©faut false
    ByteRange bool
    // Active la navigation des r√©pertoires.
    // Optionnel. Valeur par d√©faut faux.
    Parcourir bool
    // Fichier d'index pour servir un r√©pertoire.
    // Optionnel. Valeur par d√©faut "index.html".
    Cha√Æne d'index
}
```
{% endcode %}

{% code title="Example" %}
```go
applicationStatic("/", "./public", fibre.Static{
  Compress: true,
  ByteRange: true,
  Browse: true,
  Index: "john.html"
})
```
{% endcode %}

## M√©thodes HTTP

Route une requ√™te HTTP, o√π **METHOD** est la m√©thode [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) de la requ√™te.

{% code title="Signatures" %}
```go
// Ajouter vous permet de sp√©cifier une m√©thode en tant que valeur de l'application
.Add(method, path string, handlers ...func(*Ctx)) *Route

// All will register the route on all methods
app.All(path string, handlers ...func(*Ctx)) []*Route

// HTTP methods
app.Get(path string, handlers ...func(*Ctx)) *Route
app.Put(path string, handlers ...func(*Ctx)) *Route
app.Post(path string, handlers ...func(*Ctx)) *Route
app.Head(path string, handlers ...func(*Ctx)) *Route
app.Patch(path string, handlers ...func(*Ctx)) *Route
app.Trace(path string, handlers ...func(*Ctx)) *Route
app.Delete(path string, handlers ...func(*Ctx)) *Route
app.Connect(path string, handlers ...func(*Ctx)) *Route
app.Options(cha√Æne de chemin, gestionnaires... unc(*Ctx)) *Route

// L'utilisation est principalement utilis√©e pour les modules middleware
// Ces routes ne correspondent qu'√† la mise √† jour de chaque chemin
// i. . "/john" correspondra √† l'app "/john/doe", "/johnnnn"
.Utiliser(gestionnaires...func(*Ctx)) *Router l'application
.Use(prefix string, handlers ...func(*Ctx)) *Route
```
{% endcode %}

{% code title="Example" %}
```go
applicationUtilisation("/api", func(c *fibre.Ctx) {
  c.Ensemble ("X-Custom-Header", al√©atoire.String(32))
  c.Next()
}) application
.Get("/api/list", func(c *fiber.Ctx) {
  c.Envoyer("Je suis une demande GET !")
})
app.Post("/api/register", func(c *fibre.Ctx) {
  c.Envoyer("Je suis une requ√™te POST !")
})
```
{% endcode %}

## Groupes

Vous pouvez regrouper les routes en cr√©ant un struct `*Grouper`.

**Signature**

```go
applicationGroup(prefix string, handlers ...func(*Ctx)) *Groupe
```

**Exemple**

```go
func main() {
  app := fibre.New()

  api := application.Groupe("/api", handler) // /api

  v1 := api.Groupe ("/v1", handler) // /api/v1
  v1.Get("/list", handler)          // /api/v1/list
  v1.Get("/user", handler) // /api/v1/user

  v2 := api.Groupe ("/v2", handler) // /api/v2
  v2.Get("/list", handler)          // /api/v2/list
  v2.Get("/user", handler) // /api/v2/user

  app.√âcoute(3000)
}
```

## √âcouter

Lie et √©coute les connexions sur l'adresse sp√©cifi√©e. Cela peut √™tre un `int` pour le port ou une cha√Æne `` pour l'adresse.

{% code title="Signature" %}
```go
applicationEcoutez(interface{}, tls ...*tls.Erreur de configuration
```
{% endcode %}

{% code title="Examples" %}
```go
application√âcoute(8080)
application.Listen("8080")
application.Listen(":8080")
application.Listen("127.0.0.1:80")
```
{% endcode %}

Pour activer **TLS/HTTPS** vous pouvez ajouter une configuration [**TLS**](https://golang.org/pkg/crypto/tls/#Config).

{% code title="Example" %}
```go
cer, erreur := tls.LoadX509KeyPair("server.crt", "server.key")
if err != nil {
    log.Fatal(err)
}
config := &tls.Config{Certificates: []tls.Certificat{cer}} application

.Listen(443, config)
```
{% endcode %}

## Servir

Vous pouvez passer votre propre r√©seau [`.√âcouteur`](https://golang.org/pkg/net/#Listener) en utilisant la m√©thode `Serve`.

{% code title="Signature" %}
```go
applicationServe(ln net.Ecoutez, tls ...*tls.Erreur de configuration
```
{% endcode %}

{% hint style="warning" %}
**Serve** ne supporte pas la fonctionnalit√© [**Prefork**](app.md#settings).
{% endhint %}

{% code title="Example" %}
```go
if ln, errr = net.Listen("tcp4", ":8080"); errr != nil {
    log.Application Fatal(err)
}

.Serve(ln)
```
{% endcode %}

## Tester

Tester votre application est fait avec la m√©thode **Tester**. Utilisez cette m√©thode pour cr√©er des fichiers `_test.go` ou quand vous devez d√©boguer votre logique de routage. Le timeout par d√©faut est `200ms` si vous voulez d√©sactiver un timeout compl√®tement, passez `-1` comme second argument.

{% code title="Signature" %}
```go
applicationTest(req *http.Demande, msTimeout ...int) (*http.R√©ponse, erreur)
```
{% endcode %}

{% code title="Example" %}
```go
// Cr√©er une route avec la m√©thode GET pour le test:
application.Get("/", func(c *Ctx) {
  fmt.Println(c.BaseURL())              // => http://google.com
  fmt.Println(c.Get("X-Custom-Header")) // => hi

  c.Envoyer("Bonjour, Monde !")
})

// http.Requ√™te
req := httptest.NewRequest("GET", "http://google.com", nil)
req.En-t√™te.Set("X-Custom-Header", "hi")

// http.R√©ponse
resp, _ := app.Test(req)

// Faire quelque chose avec les r√©sultats :
si resp.StatusCode == 200 {
  corps, _ := ioutil.Tout lire(resp.Body)
  fmt.Println(string(body)) // => Bonjour, Monde!
}
```
{% endcode %}

